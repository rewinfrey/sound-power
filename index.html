<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sound Power Flow Visualization</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
    }
    canvas {
      border: 1px solid black;
    }
    .controls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .control-group {
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>Sound Power Flow Visualization</h1>
  <canvas id="chart" width="800" height="400"></canvas>
  <div class="controls">
    <div class="control-group">
      <label for="h">Height (h) [ft]: <span id="hValue">26</span></label>
      <input type="range" id="h" min="20" max="32" step="1" value="26">
    </div>
  </div>
  <script>
    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');
    const hSlider = document.getElementById('h');
    const hValue = document.getElementById('hValue');

    const width = canvas.width;
    const height = canvas.height;
    const padding = 50;

    // Fixed axis limits
    const xMin = 1;
    const xMax = 50;
    const PMax = 20;

    // Function to calculate P based on a numerical approximation of the integral
    function calculateP(alpha, x, h) {
      const step = Math.PI / 100; // Step size for integration
      let integral = 0;
      for (let theta = 0; theta < Math.PI / 2; theta += step) {
        const numerator = (1 - alpha) * x * Math.tan(theta);
        const denominator = Math.sqrt(1 + Math.pow(x / (h * Math.cos(theta)), 2));
        integral += (numerator / denominator) * step;
      }
      return (2 / Math.PI) * integral;
    }

    // Function to draw the chart
    function drawChart(h) {
      ctx.clearRect(0, 0, width, height);

      // Draw axes
      ctx.strokeStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding); // x-axis
      ctx.lineTo(width - padding, padding);         // y-axis
      ctx.stroke();

      // Add labels to axes
      ctx.font = '14px Arial';
      ctx.fillText('Distance from Exit (x) [ft]', width / 2 - 50, height - 10);
      ctx.save();
      ctx.translate(width - 10, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Power Flow (P)', 0, 0);
      ctx.restore();

      // Draw x-axis ticks and labels
      const xStep = 10; // Step size for distance ticks
      for (let x = xMin; x <= xMax; x += xStep) {
        const xPos = padding + ((x - xMin) / (xMax - xMin)) * (width - 2 * padding);
        ctx.beginPath();
        ctx.moveTo(xPos, height - padding);
        ctx.lineTo(xPos, height - padding + 5);
        ctx.stroke();
        ctx.fillText(x, xPos - 10, height - padding + 20);
      }

      // Draw y-axis ticks and labels on the right
      const PStep = PMax / 5; // 5 steps for power flow
      for (let P = 0; P <= PMax; P += PStep) {
        const yPos = height - padding - (P / PMax) * (height - 2 * padding);
        ctx.beginPath();
        ctx.moveTo(width - padding, yPos);
        ctx.lineTo(width - padding + 5, yPos);
        ctx.stroke();
        ctx.fillText(P.toFixed(1), width - padding + 10, yPos + 5);
      }

      // Draw multiple lines for alpha values
      const alphaValues = Array.from({ length: 11 }, (_, i) => i * 0.1); // Alpha values: 0, 0.1, ..., 1
      const xValues = Array.from({ length: 50 }, (_, i) => xMin + (i * (xMax - xMin)) / 49);

      alphaValues.forEach(alpha => {
        const PValues = xValues.map(x => calculateP(alpha, x, h));
        ctx.strokeStyle = `rgba(${255 - alpha * 255}, ${alpha * 255}, 128, 1)`; // Gradient colors
        ctx.beginPath();
        xValues.forEach((x, i) => {
          const xPos = padding + ((x - xMin) / (xMax - xMin)) * (width - 2 * padding);
          const y = height - padding - (PValues[i] / PMax) * (height - 2 * padding);
          if (i === 0) {
            ctx.moveTo(xPos, y);
          } else {
            ctx.lineTo(xPos, y);
          }
        });
        ctx.stroke();

        // Add label above each line near the left edge
        const labelX = padding - 40;
        const labelY = height - padding - (PValues[0] / PMax) * (height - 2 * padding) - 5;
        ctx.fillStyle = 'black';
        ctx.font = '10px Arial';
        ctx.fillText(`Î±=${alpha.toFixed(1)}`, labelX, labelY);
      });

      // Add a black border below the x-axis
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, height - padding + 5);
      ctx.lineTo(width - padding, height - padding + 5);
      ctx.stroke();
      ctx.lineWidth = 1; // Reset line width
    }

    // Event listener for the height slider
    hSlider.addEventListener('input', () => {
      const h = parseFloat(hSlider.value);
      hValue.textContent = h.toFixed(0);
      drawChart(h);
    });

    // Initial draw
    drawChart(parseFloat(hSlider.value));
  </script>
</body>
</html>
